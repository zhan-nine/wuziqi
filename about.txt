made by 张欣培
这里是使用说明
代码文件一共有：
main.c
gameboard.c
check.c
find_2345.c
forbid.c
assist.c
p2c_chimp.c 
myhead.h
八个文件，将这些文件放在一个文件夹下对main.c进行编译即可。
代码特色：
1.最低的搜索层数2层，实测我的代码增加层数不能显著提高胜率。因此这是速度最快的代码。限制计算速度的函数主要是find_2345()，但这个是减少层数最重要的。
2.部分随机化算法。在机器黑棋第二步和白棋第一步，是完全随机下子，随机化极强。在得分相近的点，能够选取一个随机的点，这样可以增加机器的变化性。特别说明，不是大猩猩随机化。
3.搜索剪枝较少，因为搜索层数较少，因此剪枝较少。通过棋型加分，可以实现优势判断。
代码现存bug：
1.活四的优先度可能低于冲四
2.部分跳活三可能没法堵上
致谢：
不存在的，每一行都是我自己写的，没抄。
感谢几个前人写的程序方便我找bug，特别是我隔壁舍友田翔宇的铁王八防守型五子棋。
坐等后人致谢我。
后记：
当确定这个重视评分轻视叠层数的技术路线后我就没想过赢了。事实上大量时间在和前人的软件对下然后找我的bug，直到最后还是有小bug。
从哲学上来讲，带有随机化的下子给了它无限可能，至少不会永远输给同一个人/机。这在所有人的代码中是独一无二的，十分创新的。
应用数学上，第一步最优解+第二步最优解≠最优解。这是一个很有意思的结论，也是我这个代码的核心思想。随机化给了它走次优解的机会，于是增强了它的变化性。
如果后人有心修改我的程序，很可能成为下一届最强五子棋。限于时间，我没能在比赛前找到所有bug。